# -*- coding: utf-8 -*-
"""Proyecto_Final_2023_Harold.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14Y7eFPe_dCA-TdwkPyCg0Tr1qBhe4jFq

**Elaborado por:**

+ Harold H Hernandez

_____________________________________________________________
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np # linear algebra
import pandas as pd # data processing
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
ecomm = pd.read_csv("/content/ecomm.csv")

"""#**Entendimiento de los datos**

**1.1 Entendimiento de Negocio**

El objetivo principal podría ser lograr una tasa de precisión de al menos el 80 % en la predicción de las calificaciones de los clientes dentro de un año utilizando detalles de pedidos específicos. Esto ayudará a las empresas a tomar decisiones basadas en datos sobre sus productos, estrategias de marketing y servicio al cliente. Las preguntas comerciales relacionadas son

1.  ¿Se está respondiendo la consulta del cliente?

2. ¿Se entregó el producto a tiempo?

3. ¿la importancia del producto es alta?


Para que nuestro objetivo se convierta en realidad, necesitamos un plan de proyecto que describa los pasos necesarios, las limitaciones (por ejemplo, el tamaño del conjunto de datos que se puede utilizar para el modelado), la fecha límite, los riesgos/eventos que podrían causar retrasos o fallas en el proceso. del proyecto, así como los correspondientes planes de contingencia.**

Contenido

El conjunto de datos utilizado para la construcción del modelo contenía 10999 observaciones de 12 variables.
Los datos contienen la siguiente información:

- ID: Número de identificación de los Clientes.
-  Bloque de almacén: la empresa tiene un gran almacén que se divide en bloques como A, B, C, D, F.
- Modo de envío: La empresa envía los productos de múltiples formas, como barco, vuelo y carretera.
- Llamadas de atención al cliente: Número de llamadas realizadas desde consulta para consulta del envío.
- Calificación del cliente: La empresa ha calificado a cada cliente. 1 es el más bajo (peor), 5 es el más alto (mejor).
- Costo del Producto: Costo del Producto en Dólares Estadounidenses.
- Compras Anteriores: El Número de Compra Anterior.
- Importancia del producto: La empresa ha categorizado el producto en diversos parámetros, como bajo, medio y alto.
- Género: Masculino y Femenino.
- Descuento ofrecido: Descuento ofrecido en ese producto específico.
- Peso en gms: Es el peso en gramos.
- Llegado a tiempo: Es la variable objetivo, donde 1 Indica que el producto NO ha llegado a tiempo y 0 indica que ha llegado a tiempo.

**1.2 Identificamos las columnas (variables) que componen el dataset y el tipo de dato que contiene cada una de ellas. Podemos observar que todas las variables son númericas y una de ella es de tipo entero, las demás poseen valores flotantes.**
"""

ecomm.info()

"""**2. Cambio formato nombres para que queden como titulos y busqueda de valores nulos**"""

new_cols=[]
for i in ecomm.columns[1:-1]:
    i = i.replace("_"," ")
    i = i.title()
    new_cols.append(i);
new_cols = ['ID'] +  new_cols
new_cols.append('Arrival')
ecomm.columns = new_cols
ecomm.columns.to_list()

ecomm.isnull().sum().sum()

"""**3. Estadísticas descriptivas del dataset**"""

ecomm.iloc[:,1:-1].describe()

ecomm.describe(include='object')

# Plotting multiple graphs in a grid
# Exploring the distribution of numeric columns using cumulative frequency distribution
fig, ax = plt.subplots(figsize=(20,16), facecolor='#F2F4F4')
fig.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.2, hspace=0.5)
count=1
ls = ['Cost Of The Product', 'Weight In Gms', 'Discount Offered']
for i in ls:
    plt.subplot(3,1,count)
    h = sns.histplot(x=i, kde=True, data=ecomm)
    h.set_title(('frequency distribution of ' + i).title(), fontsize=13)
    count+=1

# for categorical data
fig, axes = plt.subplots(4,2,figsize=(16,25), facecolor='#F2F4F4')

# countplot for 'Warehouse Block'
abs_whs=ecomm["Warehouse Block"].value_counts(ascending=False)
sns.countplot(x=ecomm["Warehouse Block"], order=abs_whs.index, ax=axes[0,0], palette='CMRmap_r')
axes[0,0].set_title('Orders Handled By Each Warehouse Block', fontsize=12)
rel_whs=ecomm["Warehouse Block"].value_counts(ascending=False, normalize=True).values*100
lbs_whs=[f"{w[0]} ({w[1]:.2f}%)" for w in zip(abs_whs,rel_whs)]
axes[0,0].bar_label(container=axes[0,0].containers[0], labels=lbs_whs)

# countplot for 'Mode Of Shipment'
abs_ship = ecomm["Mode Of Shipment"].value_counts(ascending=False)
sns.countplot(x=ecomm["Mode Of Shipment"], order=abs_ship.index, ax=axes[0,1], palette=['#DC143C','#556b2f','#008b8b'])
axes[0,1].set_title('Number of Orders By Shipment Mode', fontsize=12)
rel_ship = ecomm["Mode Of Shipment"].value_counts(ascending=False, normalize=True).values*100
lbs_ship = [f"{s[0]} ({s[1]:.2f}%)" for s in zip (abs_ship,rel_ship)]
axes[0,1].bar_label(container=axes[0,1].containers[0], labels=lbs_ship)

# countplot for 'Customer Care Calls'
abs_calls=ecomm["Customer Care Calls"].value_counts(ascending=False)
sns.countplot(x=ecomm["Customer Care Calls"], order=abs_calls.index,ax=axes[1,0],palette='cubehelix')
axes[1,0].set_title('Number of Customer Care Calls Made by Customers', fontsize=12)
rel_calls=ecomm["Customer Care Calls"].value_counts(ascending=False, normalize=True).values*100
lbs_calls=[f"{c[0]} ({c[1]:.2f}%)" for c in zip(abs_calls, rel_calls)]
axes[1,0].bar_label(container=axes[1,0].containers[0], labels=lbs_calls)

# countplot for 'Customer Rating'
abs_rating = ecomm["Customer Rating"].value_counts(ascending=False)
sns.countplot(x=ecomm["Customer Rating"], order=abs_rating.index,ax=axes[1,1],palette="rocket")
axes[1,1].set_title('Customer Rating Received', fontsize=12);
rel_rating = ecomm["Customer Rating"].value_counts(ascending=False, normalize=True).values*100
lbs_rating = [f"{r[0]} ({r[1]:.2f}%)" for r in zip(abs_rating, rel_rating)]
axes[1,1].bar_label(container=axes[1,1].containers[0], labels=lbs_rating)

# countplot for 'Prior Purchases'
abs_prior_pur = ecomm["Prior Purchases"].value_counts(ascending=False)
sns.countplot(x=ecomm["Prior Purchases"], order=abs_prior_pur.index,ax=axes[2,0],palette='viridis')
axes[2,0].set_title('Number of Prior Purchases Made by Customers', fontsize=12)
rel_prior_pur = ecomm["Prior Purchases"].value_counts(ascending=False, normalize=True).values*100
lbs_prior_pur = [f"{pur[0]} ({pur[1]:.0f}%)" for pur in zip(abs_prior_pur, rel_prior_pur)]
axes[2,0].bar_label(container=axes[2,0].containers[0], labels=lbs_prior_pur)

# countplot for 'Product Importance'
abs_priority = ecomm["Product Importance"].value_counts(ascending=False)
sns.countplot(x=ecomm["Product Importance"], order=abs_priority.index,ax=axes[2,1])
axes[2,1].set_title('Number of Orders Made by Product Importance', fontsize=12)
rel_priority = ecomm["Product Importance"].value_counts(ascending=False, normalize=True).values*100
lbs_priority = [f"{i[0]} ({i[1]:.2f}%)" for i in zip(abs_priority, rel_priority)]
axes[2,1].bar_label(container=axes[2,1].containers[0], labels=lbs_priority)

# countplot for 'Gender'
abs_gender = ecomm["Gender"].value_counts(ascending=False)
sns.countplot(x=ecomm["Gender"], order=abs_gender.index,ax=axes[3,0],palette=['#800000','#191970'])
axes[3,0].set_title("Number of Orders Made by Customers' Gender", fontsize=12)
rel_gender = ecomm["Gender"].value_counts(ascending=False, normalize=True).values*100
lbs_gender = [f"{g[0]} ({g[1]:.2f}%)" for g in zip(abs_gender, rel_gender)]
axes[3,0].bar_label(container=axes[3,0].containers[0], labels=lbs_gender)

# countplot for 'Arrival'
abs_arrival = ecomm["Arrival"].value_counts(ascending=False)
sns.countplot(x=ecomm["Arrival"], order=abs_arrival.index,ax=axes[3,1],palette='tab20c_r')
axes[3,1].set_title('Number of Orders Based On Arrival Time', fontsize=12)
axes[3,1].set_xticklabels(['Late', 'On Time'])
rel_arrival = ecomm["Arrival"].value_counts(ascending=False, normalize=True).values*100
lbls_arrival=[f"{a[0]}({a[1]:.2f}%)" for a in zip(abs_arrival,rel_arrival)]
axes[3,1].bar_label(container=axes[3,1].containers[0],labels=lbls_arrival);

"""**4. CONCLUSIONES ESTADISTICAS DESCRIPTIVAS**

El costo de la mayoría de los productos está dentro del rango de  240, a 275,.

El peso de la mayoría de los productos se sitúa entre 1.000 y 2.000 gramos y entre 4.000 y 6.000 gramos.

El descuento que es más probable que se otorgue es entre el 1% y el 10%.

El 33,33% de los pedidos fueron atendidos por el bloque de almacenes F, mientras que otros bloques de almacenes atendieron el resto de pedidos por igual.

La mayoría de los pedidos se enviaron por barco (67,84%), seguido del avión (16,16%) y finalmente por carretera (16%).

El 32,34% de los clientes necesitaron realizar 4 llamadas para realizar el seguimiento de su(s) envío(s). Este es un punto de alerta para la empresa ya que las inquietudes de los clientes deben resolverse lo antes posible sin necesidad de que los clientes realicen varias llamadas.

1 es la calificación con el segundo conteo más alto. Es más probable que se deba al hecho de que los productos no se entregan a tiempo y al gran número de llamadas que los clientes deben realizar.

Alrededor del 36% de los clientes habían realizado 3 compras anteriores. Hay 306 clientes fieles que han realizado al menos 8 compras anteriores. Sólo el 8,62% de los pedidos son de gran importancia. La mayoría de los pedidos son de baja importancia (48,16%).

El 50,41% de los clientes son mujeres, mientras que el resto son hombres. Más de la mitad del total de 10.999 pedidos (59,67%) llegaron con retraso.

**5. CREACIÓN MODELO**

5.1 Objetivo (también conocido como variable dependiente, variable Y, respuesta, resultado): la variable que estamos tratando de predecir.

5.2 Características: (también conocidas como variable independiente, variable X, predictor, atributo): la variable utilizada para predecir el objetivo.

5.3 Registro : (también conocido como fila, caso, instancia, ejemplo): el vector de valores predictivos y de resultado para un individuo o caso específico.

5.4 Regresión : para identificar cuánto cambia la variable de salida continua (numérica) con el cambio en una (en el caso de regresión lineal simple ) o más (en el caso de regresión lineal múltiple ) características.

5.5 Clasificación : Para predecir una etiqueta de clase , que es una elección de una lista predefinida de posibilidades. Se puede dividir en clasificación binaria (que distingue exactamente dos clases) y clasificación multiclase (que distingue entre más de dos clases).

Este estudio de caso sería una clasificación binaria, ya que asignaríamos la calificación de 2 a 5 como 0 para representar una calificación distinta de 1.

Dado que el resultado son datos categóricos, necesitamos usar modelos de clasificación ML, como regresión lógica, K-vecinos. , máquinas de vectores de soporte, etc.

Para preparar el conjunto de datos para la construcción del modelo, necesitamos escalar las variables numéricas y usarlas pandas.get_dummi es para crear variables ficticias para variables categóricas. Después de eso, debemos separar los datos en datos de entrenamiento y de prueba, así como importar las bibliotecas de algoritmos de ML necesarias para construir los modelos.
"""

# librerias para modelos
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier as DT


# crear variables ficticias para variables categóricas
ecomm['Gender'] = ecomm.Gender.map({'F':0, 'M':1})
ecomm['Customer Rating'] = ecomm['Customer Rating'].map({5:0, 4:0, 3:0, 2:0, 1:1})
dummy = pd.DataFrame(pd.get_dummies(ecomm[['Warehouse Block', 'Mode Of Shipment','Product Importance']]))

# para normalizar datos
from sklearn.preprocessing import scale
ecomm1 = pd.DataFrame(scale(ecomm[['Cost Of The Product','Discount Offered', 'Weight In Gms']]), columns=['Cost Of the Product','Discount Offered', 'Weight In Gms'])

# creaar nuevo datafame para modelado
ecomm_final = pd.concat([ecomm1, dummy,ecomm[['Customer Care Calls', 'Prior Purchases','Gender', 'Arrival','Customer Rating']]],
                        axis=1)

# Dividir datos en salida y entrada
X = ecomm_final.iloc[:,:-1] # inputs
Y = ecomm_final['Customer Rating'] # outputs

# dividir data en train data and test data
X_train, X_test, Y_train, Y_test = train_test_split(X,Y, test_size=0.25,shuffle=True)

# agregar diferentes modelos de clasificación en una matriz de clasificadores
classifiers=[]
KNN_model = KNeighborsClassifier(n_neighbors=11, metric='euclidean')
classifiers.append(KNN_model)
DT_model = DT(criterion = 'entropy',max_depth=4)
classifiers.append(DT_model)

"""**6. METRÍCAS DE LOS ALGORÍTMOS**

Se determinan las metrias de los algotimos de clasificación implementados, para definir cual es el mejor clasificador.
"""

from sklearn.metrics import accuracy_score
accuracy_train = []
accuracy_test = []
for clf in classifiers:
    clf.fit(X_train, Y_train)
    pred_train = clf.predict(X_train)
    pred_test = clf.predict(X_test)
    acc_train = accuracy_score(Y_train, pred_train)
    acc_test = accuracy_score(Y_test, pred_test)
    accuracy_train.append(acc_train)
    accuracy_test.append(acc_test)
accuracy_result = pd.DataFrame(data={'Model':['KNN','Decision Tree'],
                                     'Training Accuracy':accuracy_train,
                                     'Testing Accuracy':accuracy_test})
accuracy_result.sort_values('Testing Accuracy',ascending=False)

"""- Se define como mejor algoritmo clasificador el KNN y se ejecuta el comando Pickle para crear el modelo en python"""

import pickle

# Save the trained model using pickle
model_filename = 'Knn_model.pkl'
with open(model_filename, 'wb') as model_file:
    pickle.dump(KNN_model, model_file)
print(f"Model saved as {model_filename}")

"""**7. ESTRATEGIA DE DESCUENTOS DE LA COMPAÑIA E-COMMERCE**


*   Con una presición del modelo aproxiamdamente el 80%, se sugiere a la compañia realizar una estrategia de descuentos de por los menos de un 10% para sus productos, con el fin de garantizar una calificación de 4 por parte de sus clientes.






"""